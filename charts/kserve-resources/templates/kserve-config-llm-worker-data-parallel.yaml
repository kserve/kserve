apiVersion: serving.kserve.io/v1alpha1
kind: LLMInferenceServiceConfig
metadata:
  name: {{ include "kserve-resources.fullname" . }}-kserve-config-llm-worker-data-parallel
  labels:
  {{- include "kserve-resources.labels" . | nindent 4 }}
spec:
  template:
    containers:
    - args:
      - "\nif [ \"$KSERVE_INFER_ROCE\" = \"true\" ]; then\n  echo \"Trying to infer
        RoCE configs ... \"\n  grep -H . /sys/class/infiniband/*/ports/*/gids/* 2>/dev/null\n
        \ grep -H . /sys/class/infiniband/*/ports/*/gid_attrs/types/* 2>/dev/null\n\n
        \ KSERVE_INFER_IB_GID_INDEX_GREP=${KSERVE_INFER_IB_GID_INDEX_GREP:-\"RoCE
        v2\"}\n\n  echo \"[Infer RoCE] Discovering active HCAs ...\"\n  active_hcas=()\n
        \ # Loop through all mlx5 devices found in sysfs\n  for hca_dir in /sys/class/infiniband/mlx5_*;
        do\n      # Ensure it's a directory before proceeding\n      if [ -d \"$hca_dir\"
        ]; then\n          hca_name=$(basename \"$hca_dir\")\n          port_state_file=\"$hca_dir/ports/1/state\"
        # Assume port 1\n          type_file=\"$hca_dir/ports/1/gid_attrs/types/*\"\n\n
        \         echo \"[Infer RoCE] Check if the port state file ${port_state_file}
        exists and contains 'ACTIVE'\"\n          if [ -f \"$port_state_file\" ] &&
        grep -q \"ACTIVE\" \"$port_state_file\" && grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\"
        ${type_file} 2>/dev/null; then\n              echo \"[Infer RoCE] Found active
        HCA: $hca_name\"\n              active_hcas+=(\"$hca_name\")\n          else\n
        \             echo \"[Infer RoCE] Skipping inactive or down HCA: $hca_name\"\n
        \         fi\n      fi\n  done\n\n  ucx_hcas=()\n  for hca in \"${active_hcas[@]}\";
        do\n    ucx_hcas+=(\"${hca}:1\")\n  done\n\n  # Check if we found any active
        HCAs\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      # Join the array elements
        with a comma\n      hcas=$(IFS=,; echo \"${active_hcas[*]}\")\n      echo
        \"[Infer RoCE] Setting active HCAs: ${hcas}\"\n      export NCCL_IB_HCA=${NCCL_IB_HCA:-${hcas}}\n
        \     export NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST:-${hcas}}\n      export UCX_NET_DEVICES=${UCX_NET_DEVICES:-${ucx_hcas}}\n\n
        \     echo \"[Infer RoCE] NCCL_IB_HCA=${NCCL_IB_HCA}\"\n      echo \"[Infer
        RoCE] NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST}\"\n  else\n      echo \"[Infer
        RoCE] WARNING: No active RoCE HCAs found. NCCL_IB_HCA will not be set.\"\n
        \ fi\n\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      echo \"[Infer RoCE]
        Finding GID_INDEX for each active HCA (SR-IOV compatible)...\"\n\n      #
        For SR-IOV environments, find the most common IPv4 RoCE v2 GID index across
        all HCAs\n      declare -A gid_index_count\n      declare -A hca_gid_index\n\n
        \     for hca_name in \"${active_hcas[@]}\"; do\n          echo \"[Infer RoCE]
        Processing HCA: ${hca_name}\"\n\n          # Find all RoCE v2 IPv4 GIDs for
        this HCA and count by index\n          for tpath in /sys/class/infiniband/${hca_name}/ports/1/gid_attrs/types/*;
        do\n              if grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\" \"$tpath\"
        2>/dev/null; then\n                  idx=$(basename \"$tpath\")\n                  gid_file=\"/sys/class/infiniband/${hca_name}/ports/1/gids/${idx}\"\n
        \                 # Check for IPv4 GID (contains ffff:)\n                  if
        [ -f \"$gid_file\" ] && grep -q \"ffff:\" \"$gid_file\"; then\n                      gid_value=$(cat
        \"$gid_file\" 2>/dev/null || echo \"\")\n                      echo \"[Infer
        RoCE] Found IPv4 RoCE v2 GID for ${hca_name}: index=${idx}, gid=${gid_value}\"\n
        \                     hca_gid_index[\"${hca_name}\"]=\"${idx}\"\n                      gid_index_count[\"${idx}\"]=$((${gid_index_count[\"${idx}\"]}
        + 1))\n                      break  # Use first found IPv4 GID per HCA\n                  fi\n
        \             fi\n          done\n      done\n\n      # Find the most common
        GID index (most likely to be consistent across nodes)\n      best_gid_index=\"\"\n
        \     max_count=0\n      for idx in \"${!gid_index_count[@]}\"; do\n          count=${gid_index_count[\"${idx}\"]}\n
        \         echo \"[Infer RoCE] GID_INDEX ${idx} found on ${count} HCAs\"\n
        \         if [ $count -gt $max_count ]; then\n              max_count=$count\n
        \             best_gid_index=\"$idx\"\n          fi\n      done\n\n      #
        Use deterministic fallback if counts are equal - prefer lower index number
        \ \n      if [ ${#gid_index_count[@]} -gt 1 ]; then\n          echo \"[Infer
        RoCE] Multiple GID indices found, selecting most common: ${best_gid_index}\"\n
        \         # If there's a tie, prefer index 3 as it's most common in SR-IOV
        setups\n          if [ -n \"${gid_index_count['3']}\" ] && [ \"${gid_index_count['3']}\"
        -eq \"$max_count\" ]; then\n              best_gid_index=\"3\"\n              echo
        \"[Infer RoCE] Using deterministic fallback: GID_INDEX=3 (SR-IOV standard)\"\n
        \         fi\n      fi\n\n      # Check if GID_INDEX is already set via environment
        variables\n      if [ -n \"${NCCL_IB_GID_INDEX}\" ]; then\n          echo
        \"[Infer RoCE] Using pre-configured NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX}
        from environment\"\n          export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
        \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
        \         echo \"[Infer RoCE] Using hardcoded GID_INDEX=${NCCL_IB_GID_INDEX}
        for NCCL, NVSHMEM, and UCX\"\n      elif [ -n \"$best_gid_index\" ]; then\n
        \         echo \"[Infer RoCE] Selected GID_INDEX: ${best_gid_index} (found
        on ${max_count} HCAs)\"\n\n          export NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX:-$best_gid_index}\n
        \         export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$best_gid_index}\n
        \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$best_gid_index}\n\n
        \         echo \"[Infer RoCE] Exported GID_INDEX=${best_gid_index} for NCCL,
        NVSHMEM, and UCX\"\n      else\n          echo \"[Infer RoCE] ERROR: No valid
        IPv4 ${KSERVE_INFER_IB_GID_INDEX_GREP} GID_INDEX found on any HCA.\"\n      fi\n
        \ else\n      echo \"[Infer RoCE] No active HCAs found, skipping GID_INDEX
        inference.\"\n  fi\nfi\n\nSTART_RANK=0\neval \"vllm serve \\\n  /mnt/models
        \\\n  --served-model-name \"{{ "{{" }} .Spec.Model.Name {{ "}}" }}\" \\\n  --port 8000 \\\n
        \ --api-server-count ${VLLM_API_SERVER_COUNT:-8} \\\n  --disable-log-requests
        \\\n  {{ "{{" }} - if .Spec.Parallelism.Expert - {{ "}}" }}--enable-expert-parallel{{ "{{" }} - end {{ "}}" }}
        \\\n  {{ "{{" }} - if .Spec.Parallelism.Tensor - {{ "}}" }}--tensor-parallel-size {{ "{{" }} .Spec.Parallelism.Tensor {{ "}}" }}{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-size {{ "{{" }} or .Spec.Parallelism.Data 1 {{ "}}" }}
        \\\n  --data-parallel-size-local {{ "{{" }} or .Spec.Parallelism.DataLocal 1 {{ "}}" }} \\\n
        \ --data-parallel-address $(LWS_LEADER_ADDRESS) \\\n  --data-parallel-rpc-port
        {{ "{{" }} if .Spec.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} .Spec.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} else {{ "}}" }}5555{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-start-rank $START_RANK \\\n  ${VLLM_ADDITIONAL_ARGS}
        \\\n  --trust-remote-code\"\n  # BackendTLSPolicy is not implemented yet so
        disable SSL for now\n  # --enable-ssl-refresh \\\n  # --ssl-certfile \\\n
        \ # /etc/ssl/certs/tls.crt \\\n  # --ssl-keyfile \\\n  # /etc/ssl/certs/tls.key\""
      command:
      - /bin/bash
      - -c
      env:
      - name: HOME
        value: /home
      - name: VLLM_LOGGING_LEVEL
        value: INFO
      - name: HF_HUB_CACHE
        value: /models
      image: ghcr.io/llm-d/llm-d-dev:v0.2.2
      imagePullPolicy: IfNotPresent
      livenessProbe:
        failureThreshold: 3
        httpGet:
          path: /health
          port: 8000
          scheme: HTTP
        initialDelaySeconds: 300
        periodSeconds: 10
        timeoutSeconds: 10
      name: main
      ports:
      - containerPort: 8000
        protocol: TCP
      readinessProbe:
        failureThreshold: 60
        httpGet:
          path: /health
          port: 8000
          scheme: HTTP
        initialDelaySeconds: 200
        periodSeconds: 30
        timeoutSeconds: 5
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          add:
          - IPC_LOCK
          - SYS_RAWIO
          - NET_RAW
          drop:
          - ALL
        readOnlyRootFilesystem: false
        runAsNonRoot: false
        seccompProfile:
          type: RuntimeDefault
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: FallbackToLogsOnError
      volumeMounts:
      - mountPath: /home
        name: home
      - mountPath: /dev/shm
        name: dshm
      - mountPath: /models
        name: model-cache
      - mountPath: /etc/ssl/certs
        name: tls-certs
        readOnly: true
    terminationGracePeriodSeconds: 30
    volumes:
    - emptyDir: {}
      name: home
    - emptyDir:
        medium: Memory
        sizeLimit: 1Gi
      name: dshm
    - emptyDir: {}
      name: model-cache
    - name: tls-certs
      secret:
        secretName: '{{ "{{" }} ChildName .ObjectMeta.Name {{ "`" }}-kserve-self-signed-certs{{ "`" }} {{ "}}" }}'
  worker:
    containers:
    - args:
      - "\nif [ \"$KSERVE_INFER_ROCE\" = \"true\" ]; then\n  echo \"Trying to infer
        RoCE configs ... \"\n  grep -H . /sys/class/infiniband/*/ports/*/gids/* 2>/dev/null\n
        \ grep -H . /sys/class/infiniband/*/ports/*/gid_attrs/types/* 2>/dev/null\n\n
        \ KSERVE_INFER_IB_GID_INDEX_GREP=${KSERVE_INFER_IB_GID_INDEX_GREP:-\"RoCE
        v2\"}\n\n  echo \"[Infer RoCE] Discovering active HCAs ...\"\n  active_hcas=()\n
        \ # Loop through all mlx5 devices found in sysfs\n  for hca_dir in /sys/class/infiniband/mlx5_*;
        do\n      # Ensure it's a directory before proceeding\n      if [ -d \"$hca_dir\"
        ]; then\n          hca_name=$(basename \"$hca_dir\")\n          port_state_file=\"$hca_dir/ports/1/state\"
        # Assume port 1\n          type_file=\"$hca_dir/ports/1/gid_attrs/types/*\"\n\n
        \         echo \"[Infer RoCE] Check if the port state file ${port_state_file}
        exists and contains 'ACTIVE'\"\n          if [ -f \"$port_state_file\" ] &&
        grep -q \"ACTIVE\" \"$port_state_file\" && grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\"
        ${type_file} 2>/dev/null; then\n              echo \"[Infer RoCE] Found active
        HCA: $hca_name\"\n              active_hcas+=(\"$hca_name\")\n          else\n
        \             echo \"[Infer RoCE] Skipping inactive or down HCA: $hca_name\"\n
        \         fi\n      fi\n  done\n\n  ucx_hcas=()\n  for hca in \"${active_hcas[@]}\";
        do\n    ucx_hcas+=(\"${hca}:1\")\n  done\n\n  # Check if we found any active
        HCAs\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      # Join the array elements
        with a comma\n      hcas=$(IFS=,; echo \"${active_hcas[*]}\")\n      echo
        \"[Infer RoCE] Setting active HCAs: ${hcas}\"\n      export NCCL_IB_HCA=${NCCL_IB_HCA:-${hcas}}\n
        \     export NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST:-${hcas}}\n      export UCX_NET_DEVICES=${UCX_NET_DEVICES:-${ucx_hcas}}\n\n
        \     echo \"[Infer RoCE] NCCL_IB_HCA=${NCCL_IB_HCA}\"\n      echo \"[Infer
        RoCE] NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST}\"\n  else\n      echo \"[Infer
        RoCE] WARNING: No active RoCE HCAs found. NCCL_IB_HCA will not be set.\"\n
        \ fi\n\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      echo \"[Infer RoCE]
        Finding GID_INDEX for each active HCA (SR-IOV compatible)...\"\n\n      #
        For SR-IOV environments, find the most common IPv4 RoCE v2 GID index across
        all HCAs\n      declare -A gid_index_count\n      declare -A hca_gid_index\n
        \     \n      for hca_name in \"${active_hcas[@]}\"; do\n          echo \"[Infer
        RoCE] Processing HCA: ${hca_name}\"\n          \n          # Find all RoCE
        v2 IPv4 GIDs for this HCA and count by index\n          for tpath in /sys/class/infiniband/${hca_name}/ports/1/gid_attrs/types/*;
        do\n              if grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\" \"$tpath\"
        2>/dev/null; then\n                  idx=$(basename \"$tpath\")\n                  gid_file=\"/sys/class/infiniband/${hca_name}/ports/1/gids/${idx}\"\n
        \                 # Check for IPv4 GID (contains ffff:)\n                  if
        [ -f \"$gid_file\" ] && grep -q \"ffff:\" \"$gid_file\"; then\n                      gid_value=$(cat
        \"$gid_file\" 2>/dev/null || echo \"\")\n                      echo \"[Infer
        RoCE] Found IPv4 RoCE v2 GID for ${hca_name}: index=${idx}, gid=${gid_value}\"\n
        \                     hca_gid_index[\"${hca_name}\"]=\"${idx}\"\n                      gid_index_count[\"${idx}\"]=$((${gid_index_count[\"${idx}\"]}
        + 1))\n                      break  # Use first found IPv4 GID per HCA\n                  fi\n
        \             fi\n          done\n      done\n\n      # Find the most common
        GID index (most likely to be consistent across nodes)\n      best_gid_index=\"\"\n
        \     max_count=0\n      for idx in \"${!gid_index_count[@]}\"; do\n          count=${gid_index_count[\"${idx}\"]}\n
        \         echo \"[Infer RoCE] GID_INDEX ${idx} found on ${count} HCAs\"\n
        \         if [ $count -gt $max_count ]; then\n              max_count=$count\n
        \             best_gid_index=\"$idx\"\n          fi\n      done\n\n      #
        Use deterministic fallback if counts are equal - prefer lower index number
        \ \n      if [ ${#gid_index_count[@]} -gt 1 ]; then\n          echo \"[Infer
        RoCE] Multiple GID indices found, selecting most common: ${best_gid_index}\"\n
        \         # If there's a tie, prefer index 3 as it's most common in SR-IOV
        setups\n          if [ -n \"${gid_index_count['3']}\" ] && [ \"${gid_index_count['3']}\"
        -eq \"$max_count\" ]; then\n              best_gid_index=\"3\"\n              echo
        \"[Infer RoCE] Using deterministic fallback: GID_INDEX=3 (SR-IOV standard)\"\n
        \         fi\n      fi\n\n      # Check if GID_INDEX is already set via environment
        variables\n      if [ -n \"${NCCL_IB_GID_INDEX}\" ]; then\n          echo
        \"[Infer RoCE] Using pre-configured NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX}
        from environment\"\n          export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
        \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
        \         echo \"[Infer RoCE] Using hardcoded GID_INDEX=${NCCL_IB_GID_INDEX}
        for NCCL, NVSHMEM, and UCX\"\n      elif [ -n \"$best_gid_index\" ]; then\n
        \         echo \"[Infer RoCE] Selected GID_INDEX: ${best_gid_index} (found
        on ${max_count} HCAs)\"\n          \n          export NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX:-$best_gid_index}\n
        \         export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$best_gid_index}\n
        \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$best_gid_index}\n          \n
        \         echo \"[Infer RoCE] Exported GID_INDEX=${best_gid_index} for NCCL,
        NVSHMEM, and UCX\"\n      else\n          echo \"[Infer RoCE] ERROR: No valid
        IPv4 ${KSERVE_INFER_IB_GID_INDEX_GREP} GID_INDEX found on any HCA.\"\n      fi\n
        \ else\n      echo \"[Infer RoCE] No active HCAs found, skipping GID_INDEX
        inference.\"\n  fi\nfi\n\nSTART_RANK=$(( ${LWS_WORKER_INDEX:-0} * {{ "{{" }} or .Spec.Parallelism.DataLocal
        1 {{ "}}" }} ))\neval \"vllm serve \\\n  /mnt/models \\\n  --served-model-name \"{{ "{{" }} .Spec.Model.Name {{ "}}" }}\" \\\n  --port 8000 \\\n  --disable-log-requests \\\n
        \ {{ "{{" }} - if .Spec.Parallelism.Expert {{ "}}" }}--enable-expert-parallel{{ "{{" }} - end {{ "}}" }} \\\n
        \ {{ "{{" }} - if .Spec.Parallelism.Tensor {{ "}}" }}--tensor-parallel-size {{ "{{" }} .Spec.Parallelism.Tensor {{ "}}" }}{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-size {{ "{{" }} or .Spec.Parallelism.Data 1 {{ "}}" }}
        \\\n  --data-parallel-size-local {{ "{{" }} or .Spec.Parallelism.DataLocal 1 {{ "}}" }} \\\n
        \ --data-parallel-address $(LWS_LEADER_ADDRESS) \\\n  --data-parallel-rpc-port
        {{ "{{" }} if .Spec.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} .Spec.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} else {{ "}}" }}5555{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-start-rank $START_RANK \\\n  ${VLLM_ADDITIONAL_ARGS}
        \\\n  --trust-remote-code \\\n  --headless\"\n  # BackendTLSPolicy is not
        implemented yet so disable SSL for now\n  # --enable-ssl-refresh \\\n  # --ssl-certfile
        \\\n  # /etc/ssl/certs/tls.crt \\\n  # --ssl-keyfile \\\n  # /etc/ssl/certs/tls.key"
      command:
      - /bin/bash
      - -c
      env:
      - name: HOME
        value: /home
      - name: VLLM_LOGGING_LEVEL
        value: INFO
      - name: HF_HUB_CACHE
        value: /models
      image: ghcr.io/llm-d/llm-d-dev:v0.2.2
      imagePullPolicy: IfNotPresent
      name: main
      ports:
      - containerPort: 8000
        protocol: TCP
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          add:
          - IPC_LOCK
          - SYS_RAWIO
          - NET_RAW
          drop:
          - ALL
        readOnlyRootFilesystem: false
        runAsNonRoot: false
        seccompProfile:
          type: RuntimeDefault
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: FallbackToLogsOnError
      volumeMounts:
      - mountPath: /home
        name: home
      - mountPath: /dev/shm
        name: dshm
      - mountPath: /models
        name: model-cache
      - mountPath: /etc/ssl/certs
        name: tls-certs
        readOnly: true
    terminationGracePeriodSeconds: 30
    volumes:
    - emptyDir: {}
      name: home
    - emptyDir:
        medium: Memory
        sizeLimit: 1Gi
      name: dshm
    - emptyDir: {}
      name: model-cache
    - name: tls-certs
      secret:
        secretName: '{{ "{{" }} ChildName .ObjectMeta.Name {{ "`" }}-kserve-self-signed-certs{{ "`" }} {{ "}}" }}'
