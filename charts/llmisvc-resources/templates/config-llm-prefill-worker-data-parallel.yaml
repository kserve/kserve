apiVersion: serving.kserve.io/v1alpha1
kind: LLMInferenceServiceConfig
metadata:
  name: kserve-config-llm-prefill-worker-data-parallel
  labels:
  {{- include "llm-isvc-resources.labels" . | nindent 4 }}
spec:
  prefill:
    template:
      containers:
      - args:
        - "\nif [ \"$KSERVE_INFER_ROCE\" = \"true\" ]; then\n  echo \"Trying to infer
          RoCE configs ... \"\n  grep -H . /sys/class/infiniband/*/ports/*/gids/*
          2>/dev/null\n  grep -H . /sys/class/infiniband/*/ports/*/gid_attrs/types/*
          2>/dev/null\n\n  KSERVE_INFER_IB_GID_INDEX_GREP=${KSERVE_INFER_IB_GID_INDEX_GREP:-\"RoCE
          v2\"}\n\n  echo \"[Infer RoCE] Discovering active HCAs ...\"\n  active_hcas=()\n
          \ # Loop through all mlx5 devices found in sysfs\n  for hca_dir in /sys/class/infiniband/mlx5_*;
          do\n      # Ensure it's a directory before proceeding\n      if [ -d \"$hca_dir\"
          ]; then\n          hca_name=$(basename \"$hca_dir\")\n          port_state_file=\"$hca_dir/ports/1/state\"
          # Assume port 1\n          type_file=\"$hca_dir/ports/1/gid_attrs/types/*\"\n\n
          \         echo \"[Infer RoCE] Check if the port state file ${port_state_file}
          exists and contains 'ACTIVE'\"\n          if [ -f \"$port_state_file\" ]
          && grep -q \"ACTIVE\" \"$port_state_file\" && grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\"
          ${type_file} 2>/dev/null; then\n              echo \"[Infer RoCE] Found
          active HCA: $hca_name\"\n              active_hcas+=(\"$hca_name\")\n          else\n
          \             echo \"[Infer RoCE] Skipping inactive or down HCA: $hca_name\"\n
          \         fi\n      fi\n  done\n\n  ucx_hcas=()\n  for hca in \"${active_hcas[@]}\";
          do\n    ucx_hcas+=(\"${hca}:1\")\n  done\n\n  # Check if we found any active
          HCAs\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      # Join the array elements
          with a comma\n      hcas=$(IFS=,; echo \"${active_hcas[*]}\")\n      echo
          \"[Infer RoCE] Setting active HCAs: ${hcas}\"\n      export NCCL_IB_HCA=${NCCL_IB_HCA:-${hcas}}\n
          \     export NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST:-${hcas}}\n      export
          UCX_NET_DEVICES=${UCX_NET_DEVICES:-${ucx_hcas}}\n\n      echo \"[Infer RoCE]
          NCCL_IB_HCA=${NCCL_IB_HCA}\"\n      echo \"[Infer RoCE] NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST}\"\n
          \ else\n      echo \"[Infer RoCE] WARNING: No active RoCE HCAs found. NCCL_IB_HCA
          will not be set.\"\n  fi\n\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      echo
          \"[Infer RoCE] Finding GID_INDEX for each active HCA (SR-IOV compatible)...\"\n\n
          \     # For SR-IOV environments, find the most common IPv4 RoCE v2 GID index
          across all HCAs\n      declare -A gid_index_count\n      declare -A hca_gid_index\n\n
          \     for hca_name in \"${active_hcas[@]}\"; do\n          echo \"[Infer
          RoCE] Processing HCA: ${hca_name}\"\n\n          # Find all RoCE v2 IPv4
          GIDs for this HCA and count by index\n          for tpath in /sys/class/infiniband/${hca_name}/ports/1/gid_attrs/types/*;
          do\n              if grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\" \"$tpath\"
          2>/dev/null; then\n                  idx=$(basename \"$tpath\")\n                  gid_file=\"/sys/class/infiniband/${hca_name}/ports/1/gids/${idx}\"\n
          \                 # Check for IPv4 GID (contains ffff:)\n                  if
          [ -f \"$gid_file\" ] && grep -q \"ffff:\" \"$gid_file\"; then\n                      gid_value=$(cat
          \"$gid_file\" 2>/dev/null || echo \"\")\n                      echo \"[Infer
          RoCE] Found IPv4 RoCE v2 GID for ${hca_name}: index=${idx}, gid=${gid_value}\"\n
          \                     hca_gid_index[\"${hca_name}\"]=\"${idx}\"\n                      gid_index_count[\"${idx}\"]=$((${gid_index_count[\"${idx}\"]}
          + 1))\n                      break  # Use first found IPv4 GID per HCA\n
          \                 fi\n              fi\n          done\n      done\n\n      #
          Find the most common GID index (most likely to be consistent across nodes)\n
          \     best_gid_index=\"\"\n      max_count=0\n      for idx in \"${!gid_index_count[@]}\";
          do\n          count=${gid_index_count[\"${idx}\"]}\n          echo \"[Infer
          RoCE] GID_INDEX ${idx} found on ${count} HCAs\"\n          if [ $count -gt
          $max_count ]; then\n              max_count=$count\n              best_gid_index=\"$idx\"\n
          \         fi\n      done\n\n      # Use deterministic fallback if counts
          are equal - prefer lower index number  \n      if [ ${#gid_index_count[@]}
          -gt 1 ]; then\n          echo \"[Infer RoCE] Multiple GID indices found,
          selecting most common: ${best_gid_index}\"\n          # If there's a tie,
          prefer index 3 as it's most common in SR-IOV setups\n          if [ -n \"${gid_index_count['3']}\"
          ] && [ \"${gid_index_count['3']}\" -eq \"$max_count\" ]; then\n              best_gid_index=\"3\"\n
          \             echo \"[Infer RoCE] Using deterministic fallback: GID_INDEX=3
          (SR-IOV standard)\"\n          fi\n      fi\n\n      # Check if GID_INDEX
          is already set via environment variables\n      if [ -n \"${NCCL_IB_GID_INDEX}\"
          ]; then\n          echo \"[Infer RoCE] Using pre-configured NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX}
          from environment\"\n          export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
          \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
          \         echo \"[Infer RoCE] Using hardcoded GID_INDEX=${NCCL_IB_GID_INDEX}
          for NCCL, NVSHMEM, and UCX\"\n      elif [ -n \"$best_gid_index\" ]; then\n
          \         echo \"[Infer RoCE] Selected GID_INDEX: ${best_gid_index} (found
          on ${max_count} HCAs)\"\n\n          export NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX:-$best_gid_index}\n
          \         export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$best_gid_index}\n
          \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$best_gid_index}\n\n
          \         echo \"[Infer RoCE] Exported GID_INDEX=${best_gid_index} for NCCL,
          NVSHMEM, and UCX\"\n      else\n          echo \"[Infer RoCE] ERROR: No
          valid IPv4 ${KSERVE_INFER_IB_GID_INDEX_GREP} GID_INDEX found on any HCA.\"\n
          \     fi\n  else\n      echo \"[Infer RoCE] No active HCAs found, skipping
          GID_INDEX inference.\"\n  fi\nfi\n\nSTART_RANK=0\neval \"vllm serve \\\n
          \ /mnt/models \\\n  --served-model-name \"{{ "{{" }} .Spec.Model.Name {{ "}}" }}\" \\\n
          \ --port 8000 \\\n  --api-server-count ${VLLM_API_SERVER_COUNT:-8} \\\n
          \ --disable-log-requests \\\n  {{ "{{" }} - if .Spec.Prefill.Parallelism.Expert - {{ "}}" }}--enable-expert-parallel{{ "{{" }} -
          end {{ "}}" }} \\\n  {{ "{{" }} - if .Spec.Prefill.Parallelism.Tensor - {{ "}}" }}--tensor-parallel-size
          {{ "{{" }} .Spec.Prefill.Parallelism.Tensor {{ "}}" }}{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-size
          {{ "{{" }} or .Spec.Prefill.Parallelism.Data 1 {{ "}}" }} \\\n  --data-parallel-size-local
          {{ "{{" }} or .Spec.Prefill.Parallelism.DataLocal 1 {{ "}}" }} \\\n  --data-parallel-address
          $(LWS_LEADER_ADDRESS) \\\n  --data-parallel-rpc-port {{ "{{" }} if .Spec.Prefill.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} .Spec.Prefill.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} else {{ "}}" }}5555{{ "{{" }} - end {{ "}}" }} \\\n
          \ --data-parallel-start-rank $START_RANK \\\n  ${VLLM_ADDITIONAL_ARGS} \\\n
          \ --trust-remote-code\"\n  # BackendTLSPolicy is not implemented yet so
          disable SSL for now\n  # --enable-ssl-refresh \\\n  # --ssl-certfile \\\n
          \ # /etc/ssl/certs/tls.crt \\\n  # --ssl-keyfile \\\n  # /etc/ssl/certs/tls.key\""
        command:
        - /bin/bash
        - -c
        env:
        - name: HOME
          value: /home
        - name: VLLM_LOGGING_LEVEL
          value: INFO
        - name: HF_HUB_CACHE
          value: /models
        image: ghcr.io/llm-d/llm-d-dev:v0.2.2
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            path: /health
            port: 8000
            scheme: HTTP
          initialDelaySeconds: 300
          periodSeconds: 10
          timeoutSeconds: 10
        name: main
        ports:
        - containerPort: 8000
          protocol: TCP
        readinessProbe:
          failureThreshold: 60
          httpGet:
            path: /health
            port: 8000
            scheme: HTTP
          initialDelaySeconds: 200
          periodSeconds: 30
          timeoutSeconds: 5
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - IPC_LOCK
            - SYS_RAWIO
            - NET_RAW
            drop:
            - ALL
          readOnlyRootFilesystem: false
          runAsNonRoot: false
          seccompProfile:
            type: RuntimeDefault
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: FallbackToLogsOnError
        volumeMounts:
        - mountPath: /home
          name: home
        - mountPath: /dev/shm
          name: dshm
        - mountPath: /models
          name: model-cache
        - mountPath: /etc/ssl/certs
          name: tls-certs
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - emptyDir: {}
        name: home
      - emptyDir:
          medium: Memory
          sizeLimit: 1Gi
        name: dshm
      - emptyDir: {}
        name: model-cache
      - name: tls-certs
        secret:
          secretName: '{{ "{{" }} ChildName .ObjectMeta.Name {{ "`" }}-kserve-self-signed-certs{{ "`" }} {{ "}}" }}'
    worker:
      containers:
      - args:
        - "\nif [ \"$KSERVE_INFER_ROCE\" = \"true\" ]; then\n  echo \"Trying to infer
          RoCE configs ... \"\n  grep -H . /sys/class/infiniband/*/ports/*/gids/*
          2>/dev/null\n  grep -H . /sys/class/infiniband/*/ports/*/gid_attrs/types/*
          2>/dev/null\n\n  KSERVE_INFER_IB_GID_INDEX_GREP=${KSERVE_INFER_IB_GID_INDEX_GREP:-\"RoCE
          v2\"}\n\n  echo \"[Infer RoCE] Discovering active HCAs ...\"\n  active_hcas=()\n
          \ # Loop through all mlx5 devices found in sysfs\n  for hca_dir in /sys/class/infiniband/mlx5_*;
          do\n      # Ensure it's a directory before proceeding\n      if [ -d \"$hca_dir\"
          ]; then\n          hca_name=$(basename \"$hca_dir\")\n          port_state_file=\"$hca_dir/ports/1/state\"
          # Assume port 1\n          type_file=\"$hca_dir/ports/1/gid_attrs/types/*\"\n\n
          \         echo \"[Infer RoCE] Check if the port state file ${port_state_file}
          exists and contains 'ACTIVE'\"\n          if [ -f \"$port_state_file\" ]
          && grep -q \"ACTIVE\" \"$port_state_file\" && grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\"
          ${type_file} 2>/dev/null; then\n              echo \"[Infer RoCE] Found
          active HCA: $hca_name\"\n              active_hcas+=(\"$hca_name\")\n          else\n
          \             echo \"[Infer RoCE] Skipping inactive or down HCA: $hca_name\"\n
          \         fi\n      fi\n  done\n\n  ucx_hcas=()\n  for hca in \"${active_hcas[@]}\";
          do\n    ucx_hcas+=(\"${hca}:1\")\n  done\n\n  # Check if we found any active
          HCAs\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      # Join the array elements
          with a comma\n      hcas=$(IFS=,; echo \"${active_hcas[*]}\")\n      echo
          \"[Infer RoCE] Setting active HCAs: ${hcas}\"\n      export NCCL_IB_HCA=${NCCL_IB_HCA:-${hcas}}\n
          \     export NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST:-${hcas}}\n      export
          UCX_NET_DEVICES=${UCX_NET_DEVICES:-${ucx_hcas}}\n\n      echo \"[Infer RoCE]
          NCCL_IB_HCA=${NCCL_IB_HCA}\"\n      echo \"[Infer RoCE] NVSHMEM_HCA_LIST=${NVSHMEM_HCA_LIST}\"\n
          \ else\n      echo \"[Infer RoCE] WARNING: No active RoCE HCAs found. NCCL_IB_HCA
          will not be set.\"\n  fi\n\n  if [ ${#active_hcas[@]} -gt 0 ]; then\n      echo
          \"[Infer RoCE] Finding GID_INDEX for each active HCA (SR-IOV compatible)...\"\n\n
          \     # For SR-IOV environments, find the most common IPv4 RoCE v2 GID index
          across all HCAs\n      declare -A gid_index_count\n      declare -A hca_gid_index\n\n
          \     for hca_name in \"${active_hcas[@]}\"; do\n          echo \"[Infer
          RoCE] Processing HCA: ${hca_name}\"\n\n          # Find all RoCE v2 IPv4
          GIDs for this HCA and count by index\n          for tpath in /sys/class/infiniband/${hca_name}/ports/1/gid_attrs/types/*;
          do\n              if grep -q \"${KSERVE_INFER_IB_GID_INDEX_GREP}\" \"$tpath\"
          2>/dev/null; then\n                  idx=$(basename \"$tpath\")\n                  gid_file=\"/sys/class/infiniband/${hca_name}/ports/1/gids/${idx}\"\n
          \                 # Check for IPv4 GID (contains ffff:)\n                  if
          [ -f \"$gid_file\" ] && grep -q \"ffff:\" \"$gid_file\"; then\n                      gid_value=$(cat
          \"$gid_file\" 2>/dev/null || echo \"\")\n                      echo \"[Infer
          RoCE] Found IPv4 RoCE v2 GID for ${hca_name}: index=${idx}, gid=${gid_value}\"\n
          \                     hca_gid_index[\"${hca_name}\"]=\"${idx}\"\n                      gid_index_count[\"${idx}\"]=$((${gid_index_count[\"${idx}\"]}
          + 1))\n                      break  # Use first found IPv4 GID per HCA\n
          \                 fi\n              fi\n          done\n      done\n\n      #
          Find the most common GID index (most likely to be consistent across nodes)\n
          \     best_gid_index=\"\"\n      max_count=0\n      for idx in \"${!gid_index_count[@]}\";
          do\n          count=${gid_index_count[\"${idx}\"]}\n          echo \"[Infer
          RoCE] GID_INDEX ${idx} found on ${count} HCAs\"\n          if [ $count -gt
          $max_count ]; then\n              max_count=$count\n              best_gid_index=\"$idx\"\n
          \         fi\n      done\n\n      # Use deterministic fallback if counts
          are equal - prefer lower index number  \n      if [ ${#gid_index_count[@]}
          -gt 1 ]; then\n          echo \"[Infer RoCE] Multiple GID indices found,
          selecting most common: ${best_gid_index}\"\n          # If there's a tie,
          prefer index 3 as it's most common in SR-IOV setups\n          if [ -n \"${gid_index_count['3']}\"
          ] && [ \"${gid_index_count['3']}\" -eq \"$max_count\" ]; then\n              best_gid_index=\"3\"\n
          \             echo \"[Infer RoCE] Using deterministic fallback: GID_INDEX=3
          (SR-IOV standard)\"\n          fi\n      fi\n\n      # Check if GID_INDEX
          is already set via environment variables\n      if [ -n \"${NCCL_IB_GID_INDEX}\"
          ]; then\n          echo \"[Infer RoCE] Using pre-configured NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX}
          from environment\"\n          export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
          \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$NCCL_IB_GID_INDEX}\n
          \         echo \"[Infer RoCE] Using hardcoded GID_INDEX=${NCCL_IB_GID_INDEX}
          for NCCL, NVSHMEM, and UCX\"\n      elif [ -n \"$best_gid_index\" ]; then\n
          \         echo \"[Infer RoCE] Selected GID_INDEX: ${best_gid_index} (found
          on ${max_count} HCAs)\"\n\n          export NCCL_IB_GID_INDEX=${NCCL_IB_GID_INDEX:-$best_gid_index}\n
          \         export NVSHMEM_IB_GID_INDEX=${NVSHMEM_IB_GID_INDEX:-$best_gid_index}\n
          \         export UCX_IB_GID_INDEX=${UCX_IB_GID_INDEX:-$best_gid_index}\n\n
          \         echo \"[Infer RoCE] Exported GID_INDEX=${best_gid_index} for NCCL,
          NVSHMEM, and UCX\"\n      else\n          echo \"[Infer RoCE] ERROR: No
          valid IPv4 ${KSERVE_INFER_IB_GID_INDEX_GREP} GID_INDEX found on any HCA.\"\n
          \     fi\n  else\n      echo \"[Infer RoCE] No active HCAs found, skipping
          GID_INDEX inference.\"\n  fi\nfi\n\nSTART_RANK=$(( ${LWS_WORKER_INDEX:-0}
          * {{ "{{" }} or .Spec.Prefill.Parallelism.DataLocal 1 {{ "}}" }} ))\neval \"vllm serve \\\n
          \ /mnt/models \\\n  --served-model-name \"{{ "{{" }} .Spec.Model.Name {{ "}}" }}\" \\\n
          \ --port 8000 \\\n  --disable-log-requests \\\n  {{ "{{" }} - if .Spec.Prefill.Parallelism.Expert {{ "}}" }}--enable-expert-parallel{{ "{{" }} - end {{ "}}" }} \\\n  {{ "{{" }} - if .Spec.Prefill.Parallelism.Tensor {{ "}}" }}--tensor-parallel-size {{ "{{" }} .Spec.Prefill.Parallelism.Tensor {{ "}}" }}{{ "{{" }} - end {{ "}}" }}
          \\\n  --data-parallel-size {{ "{{" }} or .Spec.Prefill.Parallelism.Data 1 {{ "}}" }} \\\n
          \ --data-parallel-size-local {{ "{{" }} or .Spec.Prefill.Parallelism.DataLocal 1 {{ "}}" }} \\\n  --data-parallel-address $(LWS_LEADER_ADDRESS) \\\n  --data-parallel-rpc-port
          {{ "{{" }} if .Spec.Prefill.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} .Spec.Prefill.Parallelism.DataRPCPort {{ "}}" }}{{ "{{" }} else {{ "}}" }}5555{{ "{{" }} - end {{ "}}" }} \\\n  --data-parallel-start-rank $START_RANK
          \\\n  ${VLLM_ADDITIONAL_ARGS} \\\n  --trust-remote-code \\\n  --headless\"
          \               \n  # BackendTLSPolicy is not implemented yet so disable
          SSL for now\n  # --enable-ssl-refresh \\\n  # --ssl-certfile \\\n  # /etc/ssl/certs/tls.crt
          \\\n  # --ssl-keyfile \\\n  # /etc/ssl/certs/tls.key\""
        command:
        - /bin/bash
        - -c
        env:
        - name: HOME
          value: /home
        - name: VLLM_LOGGING_LEVEL
          value: INFO
        - name: HF_HUB_CACHE
          value: /models
        image: ghcr.io/llm-d/llm-d-dev:v0.2.2
        imagePullPolicy: IfNotPresent
        name: main
        ports:
        - containerPort: 8000
          protocol: TCP
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - IPC_LOCK
            - SYS_RAWIO
            - NET_RAW
            drop:
            - ALL
          readOnlyRootFilesystem: false
          runAsNonRoot: false
          seccompProfile:
            type: RuntimeDefault
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: FallbackToLogsOnError
        volumeMounts:
        - mountPath: /home
          name: home
        - mountPath: /dev/shm
          name: dshm
        - mountPath: /models
          name: model-cache
        - mountPath: /etc/ssl/certs
          name: tls-certs
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - emptyDir: {}
        name: home
      - emptyDir:
          medium: Memory
          sizeLimit: 1Gi
        name: dshm
      - emptyDir: {}
        name: model-cache
      - name: tls-certs
        secret:
          secretName: '{{ "{{" }} ChildName .ObjectMeta.Name {{ "`" }}-kserve-self-signed-certs{{ "`" }} {{ "}}" }}'
