/*
Copyright 2024 The KServe Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package aigateway

import (
	"context"

	aigwv1a1 "github.com/envoyproxy/ai-gateway/api/v1alpha1"
	"github.com/go-logr/logr"
	"k8s.io/apimachinery/pkg/api/equality"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	gwapiv1 "sigs.k8s.io/gateway-api/apis/v1"
	gwapiv1a2 "sigs.k8s.io/gateway-api/apis/v1alpha2"

	"github.com/kserve/kserve/pkg/apis/serving/v1beta1"
	"github.com/kserve/kserve/pkg/constants"
	isvcutils "github.com/kserve/kserve/pkg/controller/v1beta1/inferenceservice/utils"
	"github.com/kserve/kserve/pkg/utils"
)

// AIGatewayRouteReconciler manages AIGatewayRoute resources for KServe InferenceServices
type AIGatewayRouteReconciler struct {
	client.Client
	log           logr.Logger
	scheme        *runtime.Scheme
	ingressConfig *v1beta1.IngressConfig
}

// NewAIGatewayRouteReconciler creates a new AIGatewayRouteReconciler
func NewAIGatewayRouteReconciler(client client.Client, scheme *runtime.Scheme, ingressConfig *v1beta1.IngressConfig) *AIGatewayRouteReconciler {
	return &AIGatewayRouteReconciler{
		Client:        client,
		log:           ctrl.Log.WithName("AIGatewayRouteReconciler"),
		scheme:        scheme,
		ingressConfig: ingressConfig,
	}
}

// Reconcile manages the lifecycle of AIGatewayRoute resources
func (r *AIGatewayRouteReconciler) Reconcile(ctx context.Context, isvc *v1beta1.InferenceService) error {
	logger := r.log.WithValues("InferenceService", isvc.Name, "namespace", isvc.Namespace)

	// Create the desired AIGatewayRoute
	desired := r.createAIGatewayRoute(isvc)

	// Note: Not setting controller reference as cross-namespace reference is not allowed.

	// Check if AIGatewayRoute already exists
	existing := &aigwv1a1.AIGatewayRoute{}
	if err := r.Get(ctx, types.NamespacedName{
		Name:      desired.Name,
		Namespace: desired.Namespace,
	}, existing); err != nil {
		if apierrors.IsNotFound(err) {
			// Create new AIGatewayRoute
			logger.Info("Creating AIGatewayRoute", "name", desired.Name, "namespace", desired.Namespace)
			return r.Create(ctx, desired)
		} else {
			logger.Error(err, "Failed to get existing AIGatewayRoute", "name", desired.Name, "namespace", desired.Namespace)
			return err
		}
	}

	// Set ResourceVersion which is required for update operation.
	desired.ResourceVersion = existing.ResourceVersion

	// Do a dry-run update to avoid diffs generated by default values.
	// This will populate our local AIGatewayRoute with any default values that are present on the remote version.
	if err := r.Update(ctx, desired, client.DryRunAll); err != nil {
		logger.Error(err, "Failed to perform dry-run update for AIGatewayRoute", "name", desired.Name, "namespace", desired.Namespace)
		return err
	}

	// Update existing AIGatewayRoute if needed
	if !r.SemanticEquals(desired, existing) {
		logger.Info("Updating AIGatewayRoute", "name", desired.Name, "namespace", desired.Namespace)
		if err := r.Update(ctx, desired); err != nil {
			logger.Error(err, "Failed to update AIGatewayRoute", "name", desired.Name, "namespace", desired.Namespace)
			return err
		}
	}
	return nil
}

// createAIGatewayRoute creates the AIGatewayRoute resource based on InferenceService spec
func (r *AIGatewayRouteReconciler) createAIGatewayRoute(isvc *v1beta1.InferenceService) *aigwv1a1.AIGatewayRoute {
	name := isvc.Name
	gwNamespace, gwName := v1beta1.ParseIngressGateway(r.ingressConfig.KserveIngressGateway)

	// Create the AIGatewayRoute spec
	spec := aigwv1a1.AIGatewayRouteSpec{
		TargetRefs: []gwapiv1a2.LocalPolicyTargetReferenceWithSectionName{
			{
				LocalPolicyTargetReference: gwapiv1a2.LocalPolicyTargetReference{
					Group: gwapiv1a2.GroupName,
					Kind:  constants.KindGateway,
					Name:  gwapiv1a2.ObjectName(gwName),
				},
			},
		},
		APISchema: aigwv1a1.VersionedAPISchema{
			Name: aigwv1a1.APISchemaOpenAI,
		},
		Rules: []aigwv1a1.AIGatewayRouteRule{
			{
				Matches:     r.createMatches(isvc),
				BackendRefs: r.createBackendRefs(isvc),
			},
		},
		LLMRequestCosts: r.createLLMRequestCosts(),
	}

	route := &aigwv1a1.AIGatewayRoute{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: gwNamespace, // AIGatewayRoute should be in the same namespace as the gateway
			Labels: utils.Union(isvc.Labels, map[string]string{
				// Add ownership labels for AIGatewayRoute
				constants.InferenceServiceNameLabel:      isvc.Name,
				constants.InferenceServiceNamespaceLabel: isvc.Namespace,
			}),
			Annotations: isvc.Annotations,
		},
		Spec: spec,
	}
	return route
}

// createBackendRefs creates backend references from InferenceService endpoints
func (r *AIGatewayRouteReconciler) createBackendRefs(isvc *v1beta1.InferenceService) []aigwv1a1.AIGatewayRouteRuleBackendRef {
	backends := make([]aigwv1a1.AIGatewayRouteRuleBackendRef, 0, 1)
	backend := aigwv1a1.AIGatewayRouteRuleBackendRef{
		Name: getAIServiceBackendName(isvc),
		// Weight: 1,
	}
	backends = append(backends, backend)
	return backends
}

// createMatches creates route matching rules
func (r *AIGatewayRouteReconciler) createMatches(isvc *v1beta1.InferenceService) []aigwv1a1.AIGatewayRouteRuleMatch {
	matches := make([]aigwv1a1.AIGatewayRouteRuleMatch, 0, 1)

	// Add model name header match
	match := aigwv1a1.AIGatewayRouteRuleMatch{
		Headers: []gwapiv1.HTTPHeaderMatch{
			{
				Name:  gwapiv1.HTTPHeaderName(aigwv1a1.AIModelHeaderKey),
				Value: isvcutils.GetModelName(isvc),
			},
		},
	}
	matches = append(matches, match)
	return matches
}

// createLLMRequestCosts creates default LLM request costs.
func (r *AIGatewayRouteReconciler) createLLMRequestCosts() []aigwv1a1.LLMRequestCost {
	// TODO: Allow users to specify CEL expressions for cost calculation
	costs := make([]aigwv1a1.LLMRequestCost, 0, 3)
	// Add input token cost
	costs = append(costs, aigwv1a1.LLMRequestCost{
		MetadataKey: constants.MetadataKeyInputToken,
		Type:        aigwv1a1.LLMRequestCostTypeInputToken,
	})
	// Add output token cost
	costs = append(costs, aigwv1a1.LLMRequestCost{
		MetadataKey: constants.MetadataKeyOutputToken,
		Type:        aigwv1a1.LLMRequestCostTypeOutputToken,
	})
	// Add total token cost
	costs = append(costs, aigwv1a1.LLMRequestCost{
		MetadataKey: constants.MetadataKeyTotalToken,
		Type:        aigwv1a1.LLMRequestCostTypeTotalToken,
	})
	return costs
}

// SemanticEquals compares two AIGatewayRoute resources for semantic equality
func (r *AIGatewayRouteReconciler) SemanticEquals(desired, existing *aigwv1a1.AIGatewayRoute) bool {
	return equality.Semantic.DeepEqual(desired.Spec, existing.Spec) &&
		equality.Semantic.DeepEqual(desired.Labels, existing.Labels) &&
		equality.Semantic.DeepEqual(desired.Annotations, existing.Annotations)
}

func getAIGatewayRouteName(isvc *v1beta1.InferenceService) string {
	// Use the InferenceService name as the AIGatewayRoute name
	// This ensures a unique route per InferenceService
	return isvc.Name
}

// DeleteAIGatewayRoute deletes AIGatewayRoute resources associated with the InferenceService
func DeleteAIGatewayRoute(ctx context.Context, k8sClient client.Client, ingressConfig *v1beta1.IngressConfig, isvc *v1beta1.InferenceService, logger logr.Logger) error {
	logger = logger.WithValues("InferenceService", isvc.Name, "namespace", isvc.Namespace)

	// Get gateway namespace from config
	gwNamespace, _ := v1beta1.ParseIngressGateway(ingressConfig.KserveIngressGateway)
	route := &aigwv1a1.AIGatewayRoute{
		ObjectMeta: metav1.ObjectMeta{
			Name:      getAIGatewayRouteName(isvc),
			Namespace: gwNamespace,
		},
	}

	logger.Info("Deleting AIGatewayRoute", "name", route.Name, "namespace", route.Namespace)
	if err := k8sClient.Delete(ctx, route); err != nil {
		logger.Error(err, "Failed to delete AIGatewayRoute", "name", route.Name, "namespace", route.Namespace)
		return err
	}
	return nil
}
